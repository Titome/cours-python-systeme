<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="generator" content="pandoc">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
  <meta name="author" content="Arnaud Calmettes (nohar)">
  <title>La programmation système en Python</title>
  <style type="text/css">code{white-space: pre;}</style>
  <!--[if lt IE 9]>
    <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->
  <style type="text/css">
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; }
code > span.dt { color: #902000; }
code > span.dv { color: #40a070; }
code > span.bn { color: #40a070; }
code > span.fl { color: #40a070; }
code > span.ch { color: #4070a0; }
code > span.st { color: #4070a0; }
code > span.co { color: #60a0b0; font-style: italic; }
code > span.ot { color: #007020; }
code > span.al { color: #ff0000; font-weight: bold; }
code > span.fu { color: #06287e; }
code > span.er { color: #ff0000; font-weight: bold; }
  </style>
  <link rel="stylesheet" href="default.css">
  
  
  
</head>
<body>
<header>
<h1 class="title">La programmation système en Python</h1>
<h2 class="author">Arnaud Calmettes (nohar)</h2>
</header>
<nav id="TOC">
<ul>
<li><a href="#avant-propos">Avant-propos</a></li>
<li><a href="#le-noyau-et-la-coquille"><span class="toc-section-number">1</span> Le noyau et la coquille</a><ul>
<li><a href="#au-plus-proche-du-matériel-le-noyau"><span class="toc-section-number">1.1</span> Au plus proche du matériel : le noyau</a><ul>
<li><a href="#interagir-avec-le-matériel.-oui-mais"><span class="toc-section-number">1.1.1</span> Interagir avec le matériel. Oui, mais…</a></li>
<li><a href="#un-noyau-pour-les-gouverner-tous-et-dans-labstraction-les-lier"><span class="toc-section-number">1.1.2</span> Un noyau pour les gouverner tous, et dans l'abstraction les lier</a></li>
</ul></li>
<li><a href="#cas-des-unixoïdes"><span class="toc-section-number">1.2</span> Cas des Unixoïdes</a><ul>
<li><a href="#appels-systèmes-sous-unix"><span class="toc-section-number">1.2.1</span> Appels systèmes sous Unix</a></li>
<li><a href="#les-stubs-de-la-libc-et-le-module-standard-os-de-python"><span class="toc-section-number">1.2.2</span> Les <em>stubs</em> de la <code>libc</code> et le module standard <code>os</code> de Python</a></li>
</ul></li>
<li><a href="#le-shell-unix"><span class="toc-section-number">1.3</span> Le shell Unix</a><ul>
<li><a href="#conventions-de-notation"><span class="toc-section-number">1.3.1</span> Conventions de notation</a></li>
<li><a href="#utilisateurs-et-groupes"><span class="toc-section-number">1.3.2</span> Utilisateurs et groupes</a></li>
<li><a href="#les-modules-pwd-et-grp-de-la-bibliothèque-standard"><span class="toc-section-number">1.3.3</span> Les modules <code>pwd</code> et <code>grp</code> de la bibliothèque standard</a></li>
</ul></li>
</ul></li>
<li><a href="#le-système-de-fichiers"><span class="toc-section-number">2</span> Le système de fichiers</a><ul>
<li><a href="#arborescence-des-fichiers"><span class="toc-section-number">2.1</span> Arborescence des fichiers</a><ul>
<li><a href="#linterface-utilisateur-classique"><span class="toc-section-number">2.1.1</span> L'interface utilisateur classique</a></li>
<li><a href="#la-représentation-bas-niveau-les-inodes"><span class="toc-section-number">2.1.2</span> La représentation bas niveau : les <em>inodes</em></a></li>
</ul></li>
<li><a href="#manipulation-des-inodes"><span class="toc-section-number">2.2</span> Manipulation des <em>inodes</em></a><ul>
<li><a href="#lappel-système-stat"><span class="toc-section-number">2.2.1</span> L'appel système <code>stat</code></a></li>
<li><a href="#type-et-permissions-dun-fichier"><span class="toc-section-number">2.2.2</span> Type et permissions d'un fichier</a></li>
<li><a href="#modifier-les-permissions-dun-fichier"><span class="toc-section-number">2.2.3</span> Modifier les permissions d'un fichier</a></li>
</ul></li>
<li><a href="#lecture-et-écriture-de-fichiers-au-niveau-système"><span class="toc-section-number">2.3</span> Lecture et écriture de fichiers au niveau système</a><ul>
<li><a href="#inodes-et-descripteurs-de-fichiers"><span class="toc-section-number">2.3.1</span> Inodes et descripteurs de fichiers</a></li>
<li><a href="#interactions-de-base"><span class="toc-section-number">2.3.2</span> Interactions de base</a></li>
</ul></li>
<li><a href="#linterface-haut-niveau-de-python-parce-quil-qui-vous-veut-du-bien"><span class="toc-section-number">2.4</span> L'interface haut niveau de Python (parce qu'il qui vous veut du bien)</a><ul>
<li><a href="#la-toute-puissante-builtin-open"><span class="toc-section-number">2.4.1</span> La toute-puissante builtin <code>open()</code></a></li>
<li><a href="#les-flux-de-données-binaires"><span class="toc-section-number">2.4.2</span> Les flux de données binaires</a></li>
<li><a href="#les-fichiers-texte"><span class="toc-section-number">2.4.3</span> Les fichiers texte</a></li>
<li><a href="#formatage-des-données-textuelles"><span class="toc-section-number">2.4.4</span> Formatage des données textuelles</a></li>
</ul></li>
</ul></li>
<li><a href="#les-processus"><span class="toc-section-number">3</span> Les processus</a></li>
<li><a href="#le-parallélisme-multi-processus"><span class="toc-section-number">4</span> Le Parallélisme multi-processus</a></li>
<li><a href="#les-threads"><span class="toc-section-number">5</span> Les threads</a></li>
</ul>
</nav>
<h1 id="avant-propos" class="unnumbered"><a href="#avant-propos">Avant-propos</a></h1>
<p>Savez-vous comment fonctionne votre système d'exploitation ?</p>
<p>Par exemple, savez-vous de quelle façon les programmes qui tournent sur votre ordinateur sont capables de communiquer entre eux ? Connaissez-vous la différence entre un <em>thread</em> et un processus ? Ou même sans aller jusque là, avez-vous une idée de ce qu'il se passe <em>réellement</em> lorsque vous ouvrez un fichier pour le lire ?</p>
<p>Si ce n'est pas le cas, <strong>comment voulez-vous comprendre ce que font vraiment les programmes que vous écrivez ?</strong></p>
<p>Même si cela ne saute pas aux yeux, la <em>programmation système</em> n'est pas seulement utile aux barbus qui bidouillent leur Linux dans une cave. Elle permet à n'importe quel développeur d'avoir une bonne intuition de l'efficacité de ses programmes, et de comprendre le fonctionnement des mécanismes de son système d'exploitation.</p>
<p>Contrairement à tous les autres cours que vous pourrez trouver sur la programmation système, celui-ci n'utilisera pas directement le langage C, mais <em>Python</em>. Son but n'est pas de vous livrer un savoir encyclopédique (il existe déjà des kilomètres de documentation pour ça), mais plutôt de découvrir toutes ces notions <em>utiles</em>, dont certaines que vous avez sûrement déjà utilisées dans vos programmes sans forcément le savoir ni les comprendre.</p>
<p>Ainsi, l'objectif de ce cours est de compléter votre culture informatique avec des notions qui feront de vous un meilleur développeur.</p>
<p>Inévitablement, on ne peut pas faire de programmation système sans se concentrer sur un système d'exploitation particulier. Dans ce cours, nous nous pencherons de près sur le fonctionnement des systèmes qui suivent la norme POSIX, parmi lesquels on trouvera la famille des UNIX (comme BSD ou Mac OS X) ainsi que GNU/Linux.</p>
<p>Pour suivre ce cours, vous devrez :</p>
<ul>
<li>Connaître les bases de la programmation en Python. Nous prendrons Python 3.4 comme version de référence.</li>
<li>Disposer d'un ordinateur (ou d'un Raspberry Pi, ou même d'une machine virtuelle) sous GNU/Linux (ou l'un des descendants d'UNIX).</li>
<li>Ne pas prendre peur à la vue d'une ligne de commande.</li>
</ul>
<p>Alors, êtes-vous prêts à ne plus être un <em>utilisateur lambda</em> de votre OS ? La curiosité de percer ses petits secrets vous a-t'elle piqué au vif ? Ne frissonnez-vous pas de plaisir à l'idée de mettre les mains dans le cambouis ? Suivez-moi, et vous ne serez pas déçus !</p>
<h1 id="le-noyau-et-la-coquille"><a href="#le-noyau-et-la-coquille"><span class="header-section-number">1</span> Le noyau et la coquille</a></h1>
<p>Commençons par le commencement. Dans ce chapitre, nous allons survoler rapidement la façon dont sont structurées les couches basses de votre système d'exploitation. Il s'agit principalement d'un rappel des notions sur lesquelles nous construirons les chapitres suivants.</p>
<h2 id="au-plus-proche-du-matériel-le-noyau"><a href="#au-plus-proche-du-matériel-le-noyau"><span class="header-section-number">1.1</span> Au plus proche du matériel : le noyau</a></h2>
<p>Rassurez-vous, je vous ferai grâce d'un long couplet sur l'architecture des micro-processeurs. Ce n'est pas ce qui nous intéresse dans ce cours. Simplement, vous le savez comme moi, un ordinateur, c'est d'abord tout un tas de composants matériels soudés sur des cartes et connectés entre eux par des bus de données. Et puis n'oublions pas tous les périphériques reliés à ces cartes par des câbles. Bref, un ordinateur, c'est d'abord et avant tout <em>du matériel</em>.</p>
<p>En fait, <em>tous</em> les programmes que vous exécutez vont forcément, à un moment donné, devoir intéragir avec ce matériel. Au minimum, le microprocesseur devra exécuter les instructions du programme en allant piocher des données dans la mémoire vive (ou RAM). Mais pour qu'un programme serve réllemment à quelque chose, il faut bien qu'il ait des <strong>entrées</strong> et des <strong>sorties</strong>.</p>
<p>Par exemple, vous allez peut-être saisir des données sur votre <em>clavier</em>, ou bien utiliser une <em>souris</em> pour cliquer sur des boutons. Et pour voir ce que vous êtes en train de faire, ce même programme devra afficher quelque chose sur un <em>écran</em>. Peut-être même qu'il ira lire ou écrire des fichiers sur un <em>disque dur</em>, ou encore se connecter à internet pour échanger des données avec d'autres programmes qui tournent sur d'autres ordinateurs, en passant par <em>la carte réseau</em>...</p>
<p>Vous imaginez bien que tout cela ne se fait pas par magie. Pour qu'un programme utilise un périphérique matériel, <strong>il doit forcément faire appel à du code qui sert à manipuler ce matériel.</strong></p>
<p>J'entends quelqu'un murmurer le terme &quot;pilote&quot;, là bas au fond. J'y viens, patience !</p>
<h3 id="interagir-avec-le-matériel.-oui-mais"><a href="#interagir-avec-le-matériel.-oui-mais"><span class="header-section-number">1.1.1</span> Interagir avec le matériel. Oui, mais…</a></h3>
<p>Imaginons un instant que vous ayez écrit un programme capable de communiquer directement avec l'un de vos périphériques. Par exemple votre disque dur. Vous avez mis quelques bonnes semaines et englouti des douzaines de cafetières, vous avez plongé votre nez dans la documentation technique du matériel et failli vous décourager une bonne vingtaine de fois, mais ça y est, votre programme sait lire et sauvegarder des données au bon endroit sur votre disque dur et il fonctionne à merveille. Ouf !</p>
<p>Vous avez donc quelque chose de semblable à la figure 1.1.</p>
<figure>
<img src="src/img/interaction_directe.png" alt="Interaction directe avec le matériel" /><figcaption>Interaction directe avec le matériel</figcaption>
</figure>
<p>Imaginons maintenant que vous vouliez créer <em>un autre</em> programme qui ait besoin d'interagir avec ce disque dur. Manque de chance, le code de votre premier programme ne sait écrire que des fichiers de type <code>A</code> sur le disque, mais le second a besoin de lire des fichiers de type <code>B</code>. Vous voilà obligé de tout recommencer : les quelques semaines, la cafetière, la documentation technique… Sauf que cette fois-ci, vous ne vous laisserez pas avoir ! Vous allez écrire une <em>bibliothèque de fonctions</em> qui sera capable de lire et d'écrire n'importe quelle donnée sur votre disque dur. De cette manière, les programmes n'auront qu'à mettre en forme leurs données selon le type de fichier <code>A</code> ou <code>B</code>, et laisser le soin à votre bibliothèque de les charger au bon endroit sur le disque. Cette bibliothèque, c'est ce que l'on peut appeler un <strong>pilote de périphérique</strong> (on parle également de <em>pilote</em> tout court, ou bien de <em>driver</em> en anglais).</p>
<p>Vous obtenez alors une architecture similaire à la figure 1.2.</p>
<figure>
<img src="src/img/pilote.png" alt="Utilisation d&#39;un pilote" /><figcaption>Utilisation d'un pilote</figcaption>
</figure>
<p>Vous pouvez être fier de vous ! Vous avez partagé le code de votre pilote avec vos amis qui désirent interagir avec ce disque dur : ils n'ont même pas besoin de mettre le nez dans la documentation technique, ils n'ont plus qu'à se concentrer sur leurs programmes à eux.</p>
<p>Tout va bien dans le meilleur des mondes, les gens utilisent votre pilote pour lire et écrire des programmes sur le disque et celui-ci fonctionne parfaitement. En fait, il fonctionne tellement bien qu'un beau jour, au milieu de l'été, <em>le disque est rempli à ras bord de données</em>. Qu'à cela ne tienne, vous direz-vous, il suffit d'aller en acheter un deuxième. Et puis comme il y a une promo dans votre magazin, vous en trouvez un deux fois plus grand, deux fois plus rapide, deux fois plus joli et deux fois moins cher, une affaire en or ! Satisfait, vous rentrez chez vous en toute hâte, puis déballez ce petit bijou pour l'installer sur votre ordinateur, mais... il s'avère que votre nouveau disque dur n'est pas compatible avec le pilote que vous aviez développé pour le premier. La poisse !</p>
<p>Par chance, ce nouveau disque dur est livré avec une disquette<a href="#fn1" class="footnoteRef" id="fnref1"><sup>1</sup></a> d'installation qui contient son pilote. Voilà qui vous fera gagner du temps. Mais le problème c'est que les programmes que vous avez écrits jusqu'à présent savent utiliser le pilote de votre premier disque dur, mais pas celui-ci, qui n'a absolument rien à voir.</p>
<p>Résigné, vous vous laissez choir dans votre fauteuil : tout est à refaire. Décidément, <strong>interagir directement avec le matériel, c'est un véritable cauchemar</strong>. Quand ce n'est pas le code de pilotage du disque qui est mélangé aux programmes, ce sont les programmes qui ne sont pas compatibles avec les autres pilotes de disque et qu'il faut modifier chaque fois qu'un nouveau modèle arrive sur le marché. Même avec la meilleure volonté du monde, ce n'est pas gérable. En fait, de nos jours, les programmes n'interagissent jamais directement avec le matériel, sauf à la rigueur sur certains systèmes embarqués.</p>
<h3 id="un-noyau-pour-les-gouverner-tous-et-dans-labstraction-les-lier"><a href="#un-noyau-pour-les-gouverner-tous-et-dans-labstraction-les-lier"><span class="header-section-number">1.1.2</span> Un noyau pour les gouverner tous, et dans l'abstraction les lier</a></h3>
<p>Vous l'avez compris : un système d'exploitation digne de ce nom doit fournir aux programmes une interface commune, de façon à ce que ceux-ci n'aient jamais besoin de se soucier du matériel sur lequel ils agissent. Cette interface, on l'appelle <em>HAL</em> pour <em>Hardware Abstraction Layer</em> (<em>couche d'abstraction matérielle</em>). C'est cette couche qui s'occupe de charger et d'utiliser le bon pilote de périphérique en fonction du matériel qui est effectivement branché à l'ordinateur.</p>
<p>Néanmoins, cela n'est pas encore tout à fait suffisant. En effet, c'est bien joli de fournir aux développeurs une interface commune pour accéder au matériel, mais encore faut-il penser à <em>protéger</em> l'ordinateur contre le code qui fait n'importe quoi.</p>
<p>Imaginons qu'un premier programme demande à HAL de sauvegarder des données sur le disque dur. HAL va faire bien attention à trouver une adresse libre sur le matériel pour écrire ces données. Maintenant, devinez ce qu'il se passe si un second programme ne demande pas l'avis de HAL, et accède directement au disque dur pour écrire des données <em>à la même adresse</em>…</p>
<p>C'est pour cela que les systèmes d'exploitation modernes disposent d'un <strong>noyau</strong> (ou kernel) qui :</p>
<ul>
<li><strong>protège</strong> le matériel en étant <em>le seul</em> autorisé à interagir avec lui,</li>
<li>fournit aux programmes qui tournent sur la machine une <strong>interface</strong> leur permettant d'utiliser le matériel de façon contrôlée.</li>
</ul>
<p>Ainsi, le système d'exploitation va faire la distinction entre deux types de codes :</p>
<ul>
<li>le code <em>utilisateur</em> (ou <em>non-privilégié</em>), qui n'a pas le droit d'accéder au matériel,</li>
<li>le code <em>noyau</em> (ou <em>privilégié</em>) qui a tous les droits.</li>
</ul>
<p>Lorsqu'un programme utilisateur a besoin d'exécuter du code privilégié, celui-ci va réaliser un <strong>appel système</strong>. Lors de cet appel système, le programme va passer en mode privilégié et exécuter le code correspondant puis, au retour de la fonction, il repassera automatiquement en mode utilisateur.</p>
<p>Ce fonctionnement est résumé sur la figure 1.3.</p>
<figure>
<img src="src/img/noyau_syscall.png" alt="Accès au matériel sur un système moderne" /><figcaption>Accès au matériel sur un système moderne</figcaption>
</figure>
<p>Les appels systèmes en eux-mêmes sont réalisés au moyen d'une interruption matérielle. En somme, leur nature et la façon dont ils sont réalisés dépend à la fois de la machine et du système d'exploitation.</p>
<h2 id="cas-des-unixoïdes"><a href="#cas-des-unixoïdes"><span class="header-section-number">1.2</span> Cas des Unixoïdes</a></h2>
<p>La famille Unix est la plus grande famille de systèmes d'exploitation qui existe à ce jour. Ces systèmes ont tous un fonctionnement commun, qui reproduit celui du système UNIX développé par AT&amp;T durant les années 1970.</p>
<p>Dans cette famille de systèmes, on trouvera notamment GNU/Linux<a href="#fn2" class="footnoteRef" id="fnref2"><sup>2</sup></a> et OpenBSD, qui sont des systèmes d'exploitation libres, mais également Mac OS X, qui peuple les ordinateurs de la marque Apple, ainsi qu'une myriade d'autres systèmes moins connus tels que Minix, Plan9 ou GNU/Hurd.</p>
<h3 id="appels-systèmes-sous-unix"><a href="#appels-systèmes-sous-unix"><span class="header-section-number">1.2.1</span> Appels systèmes sous Unix</a></h3>
<p>Les systèmes Unix proposent tous, dans leur bibliothèque C standard (que l'on appelle la <code>libc</code>), des fonctions permettant de réaliser des appels système.</p>
<p>La plus basique d'entre elles est la fonction <code>syscall()</code> dont la signature est la suivante :</p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="dt">int</span> syscall (<span class="dt">int</span> number, ...)</code></pre>
<p>En somme, pour réaliser un appel système depuis un programme C, il suffit de passer à cette fonction le <em>numéro</em> de l'appel système en question, ainsi que les arguments attendus par celui-ci (si tel est le cas), et celle-ci retournera un entier.</p>
<p>Essayons d'utiliser cette fonction depuis Python. Pour commencer, sachez qu'il est possible de charger la <code>libc</code> et d'en utiliser les fonctions directement depuis Python, en nous servant du module standard <code>ctypes</code>. Sous GNU/Linux, la <code>libc</code> sera nommée <code>libc.so.6</code>. Chargeons-la :</p>
<pre class="sourceCode python"><code class="sourceCode python">&gt;&gt;&gt; <span class="ch">import</span> ctypes
&gt;&gt;&gt; libc = ctypes.CDLL(<span class="st">&#39;libc.so.6&#39;</span>)
&gt;&gt;&gt; libc.syscall
&lt;_FuncPtr <span class="dt">object</span> at <span class="bn">0x7f634a29a5c0</span>&gt;</code></pre>
<p>La dernière ligne nous indique que Python a bel et bien accès à la fonction standard <code>syscall</code>. Il nous suffit maintenant de trouver un numéro d'appel système à tester. Prenons-en un qui n'a besoin d'aucun argument. Par exemple, récupérons le numéro du processus dans lequel notre console Python est en train de tourner au moyen de l'appel système <code>getpid</code>. Cet appel système correspond sur ma machine (Linux 3.13 sur une architecture <code>x86_64</code>) au numéro 39.</p>
<p>Essayons !</p>
<pre class="sourceCode python"><code class="sourceCode python">&gt;&gt;&gt; libc.syscall(<span class="dv">39</span>)
<span class="dv">7827</span></code></pre>
<p>Cela semble avoir fonctionné, mais comment en être certain ?</p>
<h3 id="les-stubs-de-la-libc-et-le-module-standard-os-de-python"><a href="#les-stubs-de-la-libc-et-le-module-standard-os-de-python"><span class="header-section-number">1.2.2</span> Les <em>stubs</em> de la <code>libc</code> et le module standard <code>os</code> de Python</a></h3>
<p>En fait, dans la plupart des cas, nous n'aurons jamais besoin d'utiliser cette fonction <code>syscall()</code> directement. Déjà, sachez que la <code>libc</code> définit un certain nombre de raccourcis, appelés <em>stubs</em>, pour la plupart des appels systèmes courants. Pour en revenir à notre exemple, il existe effectivement une fonction standard <code>getpid()</code> en C, qui réalise ce même appel système :</p>
<pre class="sourceCode python"><code class="sourceCode python">&gt;&gt;&gt; libc.getpid()
<span class="dv">7827</span></code></pre>
<p>Avouez que c'est quand même plus pratique et portable que d'appeler un numéro arbitraire.</p>
<p>Maintenant, sachez que ces <em>stubs</em> sont également portés en Python. On en trouvera un très grand nombre, par exemple, dans le module <code>os</code> <em>dont c'est précisément le rôle</em><a href="#fn3" class="footnoteRef" id="fnref3"><sup>3</sup></a>. Ainsi, au lieu de charger la libc comme des barbares, nous aurions tout simplement pu utiliser la fonction <code>getpid()</code> de Python, qui réalise l'appel système du même nom !</p>
<pre class="sourceCode python"><code class="sourceCode python">&gt;&gt;&gt; <span class="ch">import</span> os
&gt;&gt;&gt; os.getpid()
<span class="dv">7827</span></code></pre>
<p>Constatez que nous obtenons bien le même résultat, que nous utilisions la fonction <code>syscall()</code>, le <em>stub</em> <code>getpid()</code> de la <code>libc</code> ou la fonction <code>os.getpid()</code> de la bibliothèque standard Python.</p>
<p>Gardez cependant cette fonction <code>syscall()</code> dans un coin de votre mémoire. Il nous arrivera peut-être un jour (ou dans un futur chapitre de ce cours) de devoir nous rappatrier sur cette fonction pour réaliser un appel système dont il n'existe ni fonction équivalente dans le module <code>os</code>, ni <em>stub</em> dans la <code>libc</code>. Dans ce cas, nous serons bien contents de pouvoir recourir à cette solution.</p>
<h2 id="le-shell-unix"><a href="#le-shell-unix"><span class="header-section-number">1.3</span> Le shell Unix</a></h2>
<p>Un système d'exploitation, ce n'est pas seulement un noyau. C'est d'ailleurs pour cette raison que l'on ne devrait jamais parler de « Linux » tout seul lorsque l'on désigne le système d'exploitation GNU/Linux : pour qu'un système soit utilisable, il faut envelopper le noyau d'une couche logicielle qui sert <em>d'interface</em> entre celui-ci et l'utilisateur. Cette interface, dans le vocabulaire Unix, porte le nom de <em>shell</em> (comme le mot anglais qui désigne une <em>coquille</em>).</p>
<p>La notion de <em>shell</em>, en raison de nombreux abus de langages, est finalement assez vague, car elle prend un sens différent selon le contexte dans lequel on y fait référence. Dans le contexte d'un système d'exploitation, le shell est l'interface qui enveloppe le noyau. Cette interface peut être <em>graphique</em> ou en <em>ligne de commande</em>, tant qu'elle désigne la couche logicielle qui permet à l'utilisateur d'interagir avec son OS. On s'accordera toutefois à dire qu'un <em>shell Unix</em> désigne bel et bien une interface en ligne de commande, puisque la norme POSIX (qui sert à uniformiser le fonctionnement des systèmes Unix) définit le format et le comportement d'un certain nombre de commandes standard.</p>
<p>En revanche, il existe plusieurs <em>shells</em> qui permettent tous de travailler avec ces mêmes commandes standard. Le plus répandu à l'heure actuelle est <code>bash</code> (pour <em>Bourne-Again SHell</em>), puisque c'est celui qui vient par défaut avec les distributions de GNU/Linux et Mac OS X.</p>
<p>À la rigueur, pour suivre ce cours, vous pouvez bien utiliser le shell que vous voudrez. Personnellement, j'utilise <code>zsh</code>, mais toutes les lignes de commande que nous taperons dans ce cours seront compatibles avec <code>bash</code>. De toute manière, dès que nous aurons besoin de réaliser des choses élaborées, nous utiliserons Python.</p>
<p>Ce cours ne portant pas sur le shell mais sur la programmation système, toutes les commandes utilisées ne seront pas nécessairement détaillées. Le lecteur est invité à découvrir la fonction de celles qu'il ne connaît pas en explorant de lui-même, soit en affichant les messages d'aide (via <code>&lt;cmd&gt; --help</code>), soit en se retournant vers le manuel standard (<code>man &lt;cmd&gt;</code>).</p>
<h3 id="conventions-de-notation"><a href="#conventions-de-notation"><span class="header-section-number">1.3.1</span> Conventions de notation</a></h3>
<p>Dans toute la suite de ce cours, nous distinguerons trois notations particulières pour différencier les lignes de commande. Les commandes à taper dans une console Python seront précédées, comme dans l'interpréteur standard, par trois chevrons fermants (<code>&gt;&gt;&gt;</code>) :</p>
<pre class="sourceCode python"><code class="sourceCode python">&gt;&gt;&gt; <span class="dt">print</span>(<span class="st">&quot;Hello, World!&quot;</span>)
Hello, World!</code></pre>
<p>Les commandes <em>shell</em> sous un utilisateur quelconque seront précédées d'un symbole <em>dollar</em> (<code>$</code>) :</p>
<pre><code>$ whoami
arnaud</code></pre>
<p>Les commandes <em>shell</em> tapées sous l'utilisateur spécial <code>root</code> seront précédées d'un symbole <em>pourcent</em> (<code>%</code>) :</p>
<pre><code>% whoami
root</code></pre>
<h3 id="utilisateurs-et-groupes"><a href="#utilisateurs-et-groupes"><span class="header-section-number">1.3.2</span> Utilisateurs et groupes</a></h3>
<p>Tous les utilisateurs d'un système Unix sont identifiés par un numéro d'utilisateur unique : leur UID (User IDentifier).</p>
<p>Par exemple, sur ma machine, je dispose de l'UID 1000 :</p>
<pre><code>$ id -u
1000</code></pre>
<p>En fait, cet UID unique est associé à un <em>nom d'utilisateur</em> dans une base de données spéciale, ce qui est beaucoup plus facile à manipuler pour nous autres, simples mortels :</p>
<pre><code>$ id -un
arnaud</code></pre>
<p>Par ailleurs, chaque utilisateur fait partie d'un ou plusieurs <strong>groupes</strong>. La plupart des utilisateurs ont un <em>groupe primaire</em> qui leur est propre (leur GID), et appartiennent possiblement à plusieurs <em>groupes secondaires</em>. De la même manière que les utilisateurs, les groupes sont désignés par un numéro de groupe unique, et associés à un nom de groupe dans une base de données. Ces groupes servent à identifier les utilisateurs qui partagent des permissions communes (nous en reparlerons plus tard).</p>
<pre><code>$ id
uid=1000(arnaud) gid=1000(arnaud) groups=1000(arnaud),4(adm),27(sudo),...</code></pre>
<p>Dans cet exemple, on s'aperçoit que j'ai l'UID 1000, que mon groupe primaire (mon GID) est le numéro 1000, et que j'appartiens également aux groupes 4 et 27 (et plein d'autres que j'ai éludés).</p>
<p>La base de données des utilisateurs s'appelle généralement <code>passwd</code>. Elle est écrite en clair dans le fichier <code>/etc/passwd</code>. La base de données des groupes, quant à elle, se trouve classiquement dans le fichier <code>/etc/groups</code>.</p>
<h3 id="les-modules-pwd-et-grp-de-la-bibliothèque-standard"><a href="#les-modules-pwd-et-grp-de-la-bibliothèque-standard"><span class="header-section-number">1.3.3</span> Les modules <code>pwd</code> et <code>grp</code> de la bibliothèque standard</a></h3>
<p>Plutôt que d'interagir directement avec ces fichiers, il est plus pratique d'utiliser respectivement les modules standard <code>pwd</code> et <code>grp</code> pour accéder en lecture aux bases de données des utilisateurs et des groupes. Leur documentation (<a href="https://docs.python.org/3.4/library/pwd.html">pwd</a>, <a href="https://docs.python.org/3.4/library/grp.html">grp</a>) est suffisamment concise pour que je me permette de vous y renvoyer directement.</p>
<p>Dans l'exemple suivant, on utilise l'appel système <code>getuid</code> pour récupérer le UID de l'utilisateur du programme, et le saluer par son login que l'on retrouve dans la base de données <code>passwd</code> via le module <code>pwd</code> :</p>
<pre class="sourceCode python"><code class="sourceCode python">&gt;&gt;&gt; <span class="ch">import</span> os, pwd
&gt;&gt;&gt; <span class="kw">def</span> say_hello():
...     pwd_struct = pwd.getpwuid(os.getuid())
...     <span class="dt">print</span>(<span class="st">&quot;Hello, {}!&quot;</span>.<span class="dt">format</span>(pwd_struct.pw_name))
...
&gt;&gt;&gt; say_hello()
Hello, arnaud!</code></pre>
<h4 id="exercices"><a href="#exercices"><span class="header-section-number">1.3.3.1</span> Exercices</a></h4>
<ol type="1">
<li><p>Compléter cette fonction <code>say_hello</code> de façon qu'elle affiche également le GID de l'utilsateur (via l'appel système <code>getgid</code>) ainsi que le nom de ce groupe en vous servant du module <code>grp</code>.</p></li>
<li><p>Utiliser ces modules pour essayer de reproduire le comportement de la commande shell <code>id</code> (au moins l'appel de base, sans option). Pour connaître tous les groupes auxquels un utilisateur appartient, vous pouvez vous servir de l'appel système <a href="https://docs.python.org/3.4/library/os.html#os.getgrouplist"><code>os.getgrouplist</code></a> qui prend en arguments le nom d'utilisateur en toutes lettres ainsi que son GID.</p></li>
</ol>
<pre class="sourceCode python"><code class="sourceCode python">&gt;&gt;&gt; os.getgrouplist(<span class="st">&#39;arnaud&#39;</span>, <span class="dv">1000</span>)
[<span class="dv">1000</span>, <span class="dv">4</span>, <span class="dv">24</span>, <span class="dv">27</span>, <span class="dv">30</span>, <span class="dv">46</span>, <span class="dv">102</span>, <span class="dv">108</span>, <span class="dv">124</span>]</code></pre>
<p>Nous aurons l'occasion de revenir sur les notions d'utilisateurs et de groupes dans plusieurs chapitres de ce cours. En particulier, chaque fois que nous parlerons des permissions, qui sont le principal mécanisme de sécurité des systèmes Unix.</p>
<h1 id="le-système-de-fichiers"><a href="#le-système-de-fichiers"><span class="header-section-number">2</span> Le système de fichiers</a></h1>
<p>En tant qu'utilisateurs réguliers de nos ordinateurs, on pourrait se demander ce qu'il y a de <em>si</em> important à propos du système de fichiers pour lui dédier un chapitre entier. En effet, c'est plutôt intuitif : c'est une arborescence composée de répertoires avec des fichiers dedans...</p>
<p>Cependant, vous avez sûrement déjà entendu quelqu'un déclarer que « Unix c'est génial parce que <em>tout est fichier</em> ». Vous n'y avez sûrement pas prêté attention sur l'instant, mais cela fait pourtant toute la différence. Figurez-vous que le système de fichiers Unix va très au-delà de la simple représentation du contenu d'un disque. C'est <strong>une puissante abstraction matérielle</strong> à la fois intuitive pour l'utilisateur et extrêmement commode pour le développeur : pour preuve, il vous suffit de savoir lire ou écrire dans un fichier pour être capable d'écouter les évènements liés aux périphériques d'entrée, interagir avec les périphériques de sortie, et même surveiller les programmes qui sont en train de s'exécuter !</p>
<p>Cela vaut bien la peine de jeter un oeil sous le capot, vous ne trouvez pas ?</p>
<h2 id="arborescence-des-fichiers"><a href="#arborescence-des-fichiers"><span class="header-section-number">2.1</span> Arborescence des fichiers</a></h2>
<h3 id="linterface-utilisateur-classique"><a href="#linterface-utilisateur-classique"><span class="header-section-number">2.1.1</span> L'interface utilisateur classique</a></h3>
<p>Commençons par enfoncer des portes ouvertes. Un système de fichiers (<em>filesystem</em>) se présentera toujours à l'utilisateur sous la forme d'une structure arborescente :</p>
<ul>
<li><p>Les noeuds de l'arbre sont appelés des <strong>répertoires</strong> (<em>directories</em> en anglais), quoique l'appellation &quot;dossier&quot; (<em>folder</em>) a été largement popularisée par les systèmes d'exploitation de chez Microsoft.</p></li>
<li><p>Les feuilles de l'arbre s'appellent des <strong>fichiers</strong> (<em>files</em>).</p></li>
<li><p>La <strong>racine</strong> du système de fichiers (<em>filesystem root</em>), est désignée conventionnellement par une simple barre oblique (<code>/</code>).</p></li>
</ul>
<figure>
<img src="src/img/filesystem_tree.png" alt="Représentation abstraite du système de fichiers" /><figcaption>Représentation abstraite du système de fichiers</figcaption>
</figure>
<p>La figure 2.1 illustre cette arborescence. Nous y voyons trois fichiers différents, dont les chemins sont respectivement <code>/usr/bin/python3.4</code> (l'interpréteur Python), <code>/bin/bash</code> (le shell <code>bash</code>) et <code>/home/arnaud/.zshrc</code> (mon fichier de configuration personnel pour le shell <code>zsh</code>).</p>
<p>Il y a d'énormes chances pour que vous manipuliez déjà des arborescences de fichiers depuis des années. Ainsi, je ne vous apprendrai rien en vous disant que la commande <code>cd</code> permet de se déplacer dans cette arborescence, que <code>pwd</code> permet d'afficher le chemin du répertoire courant et que <code>ls</code> permet de lister le contenu d'un répertoire :</p>
<pre><code>$ cd /home/arnaud/doc/cours-systeme
$ pwd
/home/arnaud/doc/cours-systeme
$ ls
makefile  src</code></pre>
<p>Peut-être vous apprendrai-je en revanche que Python permet de réaliser les mêmes opérations, notamment grâce aux appels systèmes <code>os.chdir()</code> et <code>os.getcwd()</code>, ainsi que la fonction utilitaire <code>os.listdir()</code> :</p>
<pre class="sourceCode python"><code class="sourceCode python">&gt;&gt;&gt; os.chdir(<span class="st">&#39;/home/arnaud/doc/cours-systeme&#39;</span>)
&gt;&gt;&gt; os.getcwd()
<span class="co">&#39;/home/arnaud/doc/cours-systeme&#39;</span>
&gt;&gt;&gt; os.listdir()
[<span class="st">&#39;src&#39;</span>, <span class="st">&#39;makefile&#39;</span>]</code></pre>
<p>Toutes ces notions consistent à manipuler la représentation abstraite du système de fichier que le noyau nous expose. C'est largement suffisant pour un utilisateur occasionnel d'un ordinateur, mais je suis certain que le <em>hacker</em> qui sommeille en vous est bien plus curieux que ça, et désire en savoir plus sur ce qui se cache derrière cette abstraction.</p>
<h3 id="la-représentation-bas-niveau-les-inodes"><a href="#la-représentation-bas-niveau-les-inodes"><span class="header-section-number">2.1.2</span> La représentation bas niveau : les <em>inodes</em></a></h3>
<p>Peut-être avez-vous déjà utilisé l'option <code>-l</code> de la commande standard <code>ls</code> afin d'afficher le résultat sous la forme d'une liste détaillée :</p>
<pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">ls</span> -l
<span class="kw">total</span> 628
<span class="kw">-rw-rw-r--</span> 1 arnaud arnaud    477 avril 17 22:51 makefile
<span class="kw">drwxrwxr-x</span> 3 arnaud arnaud   4096 avril 21 22:44 src</code></pre>
<p>Cette commande fait apparaître pour chaque noeud fils du répertoire courant des informations telles que l'utilisateur et le groupe propriétaires du noeud, sa taille et sa date de dernière modification. On peut légitimement se demander d'où la commande <code>ls</code> tire toutes ces infos !</p>
<p>En réalité, tous les noeuds du système de fichiers (qu'il s'agisse de fichiers simples, de répertoires, ou d'autres choses encore) sont associés en interne à une structure que l'on appelle un <em>inode</em> (de l'anglais <em>index node</em> : <em>noeud d'index</em>). Cette structure recelle de nombreuses informations, et sert à <em>indiquer</em> où se trouvent les données du noeud correspondant.</p>
<p>Ces données peuvent prendre plusieurs formes. Dans le cas d'un système de fichiers <em>réel</em> (c'est-à-dire qui correspond vraiment au contenu d'un disque dur), on pourra trouver :</p>
<ul>
<li>Des données de fichiers brutes, qui ne sont rien d'autre que des séquences d'octets.</li>
<li>Des données de répertoire. On peut se représenter un répertoire comme une collection d'<strong>entrées de répertoire</strong>. Chaque entrée associe le <em>nom</em> d'un noeud fils du répertoire au <em>numéro</em> de son inode.</li>
</ul>
<p>Pour bien se représenter cette structure à bas niveau, la figure 2.2 détaille le chemin <code>/bin/bash</code> qui consiste à traverser deux répertoires (<code>/</code> et <code>/bin</code>) pour retrouver les données du fichier <code>bash</code>.</p>
<figure>
<img src="src/img/filesystem_inodes.png" alt="Représentation physique du chemin /bin/bash" /><figcaption>Représentation physique du chemin <code>/bin/bash</code></figcaption>
</figure>
<p>Le <em>numéro d'inode</em> est un nombre permettant d'identifier un noeud de l'arborescence de façon unique sur le périphérique auquel il appartient. Pour l'afficher, il suffit de passer l'option <code>-i</code> à la commande <code>ls</code></p>
<pre><code>$ ls -i
6422940 makefile  6422937 src</code></pre>
<p>Ce dernier exemple nous montre que dans le répertoire courant, nous avons une entrée nommée <code>makefile</code> pointant sur l'inode numéro 6422940 et une entrée nommée <code>src</code> pointant sur l'inode numéro 6422937. Notez que je parle bien d'<em>entrées</em> : lorsque l'on traverse un répertoire, nous n'avons aucun moyen de savoir si une entrée donnée correspond à un fichier ou à un sous-répertoire. Pour avoir cette info, il faut aller lire les données des inodes.</p>
<h2 id="manipulation-des-inodes"><a href="#manipulation-des-inodes"><span class="header-section-number">2.2</span> Manipulation des <em>inodes</em></a></h2>
<p>La structure réelle des inodes dépend du type de système de fichiers sur lequel ils stont stockés (et il en existe des tonnes : <code>ext4</code>, <code>reiserfs</code>, <code>ramfs</code>, <code>fat32</code>, <code>ntfs</code>…). Cela dit, quelle que soit la structure adoptée par le système de fichiers, il est possible d'accéder aux données qu'elle recèle en invoquant l'appel système <code>stat</code>, ou bien la commande POSIX du même nom.</p>
<h3 id="lappel-système-stat"><a href="#lappel-système-stat"><span class="header-section-number">2.2.1</span> L'appel système <code>stat</code></a></h3>
<p>Nous nous contenterons de réaliser cet appel système depuis Python, en utilisant la fonction standard <code>os.stat()</code>.</p>
<pre class="sourceCode python"><code class="sourceCode python">&gt;&gt;&gt; stat_res = os.stat(<span class="st">&#39;/home/arnaud/doc/cours-systeme/makefile&#39;</span>)
&gt;&gt;&gt; stat_res
os.stat_result(st_mode=<span class="dv">33204</span>, st_ino=<span class="dv">6422940</span>, st_dev=<span class="dv">64513</span>, st_nlink=<span class="dv">1</span>,
               st_uid=<span class="dv">1000</span>, st_gid=<span class="dv">1000</span>, st_size=<span class="dv">477</span>, st_atime=<span class="dv">1429727097</span>,
               st_mtime=<span class="dv">1429303879</span>, st_ctime=<span class="dv">1429303879</span>)</code></pre>
<p>Le retour de cet appel système est une structure complexe que Python représente par un tuple nommé. Prenons le temps de détailler ses champs dans le tableau ci-dessous.</p>
<table>
<caption>Résultat de l'appel système <code>stat</code></caption>
<col style="width: 15%" /><col style="width: 84%" /><thead>
<tr class="header">
<th style="text-align: left;">Champ</th>
<th style="text-align: left;">Signification</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>st_mode</code></td>
<td style="text-align: left;">Nombre codé sur 16 bits, décrivant le type et les permissions du fichier.</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>st_ino</code></td>
<td style="text-align: left;">Numéro d'inode. Identifiant unique de l'inode sur le périphérique.</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>st_dev</code></td>
<td style="text-align: left;">Numéro de <em>device</em>, qui identifie le périphérique de façon unique sur le système.</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>st_nlinks</code></td>
<td style="text-align: left;">Nombre d'entrées de répertoire qui pointent vers cet inode.</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>st_uid</code></td>
<td style="text-align: left;">Identifiant de l'utilisateur propriétaire du fichier.</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>st_gid</code></td>
<td style="text-align: left;">Identifiant du groupe propriétaire du fichier.</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>st_size</code></td>
<td style="text-align: left;">Taille du fichier en octets.</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>st_atime</code></td>
<td style="text-align: left;"><em>Access time</em>. Date du dernier accès, sous la forme d'un <em>timestamp Unix</em>. Ce champ est mis à jour chaque fois qu'un programme lit les données du fichier.</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>st_mtime</code></td>
<td style="text-align: left;"><em>Modification time</em>. Date de la dernière modification. Ce champ est mis à jour chaque fois qu'un programme écrit des données dans le fichier.</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>st_ctime</code></td>
<td style="text-align: left;"><em>Status change time</em>. Date de la dernière modification de cet inode. <strong>Attention, ce n'est PAS la date de création du fichier.</strong></td>
</tr>
</tbody>
</table>
<p>Un <em>timestamp Unix</em> est une date représentée sur 32 bits. Il s'agit ni plus ni moins du nombre de secondes écoulées depuis le premier janvier 1970 à minuit (le timestamp 0), date que l'on surnomme <em>Epoch</em>. Pour décoder un timestamp en Python, il suffit d'utiliser le module <code>datetime</code> :</p>
<pre class="sourceCode python"><code class="sourceCode python">&gt;&gt;&gt; <span class="ch">from</span> datetime <span class="ch">import</span> datetime
&gt;&gt;&gt; d = datetime.fromtimestamp(<span class="dv">1429303879</span>)
&gt;&gt;&gt; <span class="dt">str</span>(d)
<span class="co">&#39;2015-04-17 22:51:19&#39;</span></code></pre>
<p>En somme, on peut en déduire qu'à l'exception du nom des fichiers, toutes les infos utiles se trouvent dans les inodes.</p>
<h3 id="type-et-permissions-dun-fichier"><a href="#type-et-permissions-dun-fichier"><span class="header-section-number">2.2.2</span> Type et permissions d'un fichier</a></h3>
<p>Le champ le plus dense en informations que nous retourne l'appel système <code>os.stat()</code> est sans aucun doute <code>st_mode</code> : il y a tellement de choses encodées sur ces 16 bits que Python dédie un module standard entier (<a href="https://docs.python.org/3.4/library/stat.html"><code>stat</code></a>) à leur manipulation !</p>
<p>Concrètement, chaque bit de ce nombre est un <em>flag</em>, c'est-à-dire une option qui peut être activée ou non. Manipuler ce style de données est monnaie courante en C, mais reste assez anecdotique chez les Pythonistes<a href="#fn4" class="footnoteRef" id="fnref4"><sup>4</sup></a>.</p>
<p>Rappelons rapidement le fonctionnement des flags binaires. Imaginons un champ <em>vierge</em>, où tous les bits sont à 0 :</p>
<pre class="sourceCode python"><code class="sourceCode python">&gt;&gt;&gt; mode = <span class="dv">0</span></code></pre>
<p>Nous pouvons vérifier si le flag <code>stat.S_IRGRP</code> (nous verrons sa signification plus loin) est activé au moyen d'un <em>ET bit-à-bit</em>, et l'activer au moyen du <em>OU bit-à-bit</em>:</p>
<pre class="sourceCode python"><code class="sourceCode python">&gt;&gt;&gt; <span class="ch">import</span> stat
&gt;&gt;&gt; <span class="dt">bool</span>(mode &amp; stat.S_IRGRP)
<span class="ot">False</span>
&gt;&gt;&gt; mode |= stat.S_IRGRP      <span class="co"># Activation du bit</span>
&gt;&gt;&gt; <span class="dt">bool</span>(mode &amp; stat.S_IRGRP)
<span class="ot">True</span></code></pre>
<p>Le système va différencier trois types d'utilisateurs pour chaque fichier :</p>
<ul>
<li>son <strong>propriétaire</strong>, dont l'UID est égal à celui du fichier (<code>st_uid</code>),</li>
<li>son <strong>groupe propriétaire</strong>, appartenant au groupe désigné par le GID du fichier (<code>st_gid</code>),</li>
<li>les <strong>autres</strong>.</li>
</ul>
<p>Pour chacun de ces types d'utilisateurs, on va définir trois <em>permissions</em> possibles :</p>
<ul>
<li>accès en lecture (l'utilisateur a le droit de lire le contenu du fichier),</li>
<li>accès en écriture (l'utilisateur a le droit de modifier le fichier),</li>
<li>accès en exécution (l'utilisateur a le droit d'exécuter le fichier).</li>
</ul>
<p>Le tableau suivant établit la correspondance entre les valeurs des <em>flags</em> du module <code>stat</code>, l'indice visuel que l'on retrouvera un peu partout, et leur signification.</p>
<table>
<caption>Masque des permissions sur un fichier</caption>
<col style="width: 12%" /><col style="width: 16%" /><col style="width: 7%" /><col style="width: 63%" /><thead>
<tr class="header">
<th style="text-align: left;">Flag</th>
<th style="text-align: left;">Mode</th>
<th style="text-align: left;">Octal</th>
<th style="text-align: left;">Signifiaction</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>S_IRUSR</code></td>
<td style="text-align: left;"><code>-r--------</code></td>
<td style="text-align: left;">0400</td>
<td style="text-align: left;">Le propriétaire du fichier a le droit d'y accéder <strong>en lecture</strong>.</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>S_IWUSR</code></td>
<td style="text-align: left;"><code>--w-------</code></td>
<td style="text-align: left;">0200</td>
<td style="text-align: left;">Le propriétaire du fichier a le droit d'y accéder <strong>en écriture</strong>.</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>S_IXUSR</code></td>
<td style="text-align: left;"><code>---x------</code></td>
<td style="text-align: left;">0100</td>
<td style="text-align: left;">Le propriétaire du fichier a le droit <strong>d'exécuter</strong> le fichier.</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>S_IRGRP</code></td>
<td style="text-align: left;"><code>----r-----</code></td>
<td style="text-align: left;">0040</td>
<td style="text-align: left;">Les membres du groupe propriétaire du fichier y ont accès <strong>en lecture</strong>.</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>S_IWGRP</code></td>
<td style="text-align: left;"><code>-----w----</code></td>
<td style="text-align: left;">0020</td>
<td style="text-align: left;">Les membres du groupe propriétaire du fichier y ont accès <strong>en écriture</strong>.</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>S_IXGRP</code></td>
<td style="text-align: left;"><code>------x---</code></td>
<td style="text-align: left;">0010</td>
<td style="text-align: left;">Les membres du groupe propriétaire du fichier ont le droit de l'<strong>exécuter</strong>.</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>S_IROTH</code></td>
<td style="text-align: left;"><code>-------r--</code></td>
<td style="text-align: left;">0004</td>
<td style="text-align: left;">Les autres utilisateurs ont accès au fichier <strong>en lecture</strong>.</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>S_IWOTH</code></td>
<td style="text-align: left;"><code>--------w-</code></td>
<td style="text-align: left;">0002</td>
<td style="text-align: left;">Les autres utilisateurs ont accès au fichier <strong>en écriture</strong>.</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>S_IXOTH</code></td>
<td style="text-align: left;"><code>---------x</code></td>
<td style="text-align: left;">0001</td>
<td style="text-align: left;">Les autres utilisateurs ont le droit d'<strong>exécuter</strong> le fichier.</td>
</tr>
</tbody>
</table>
<p>Bien évidemment, ces valeurs sont cumulatives. Ainsi, si l'on regarde celles de mon fichier <code>makefile</code> :</p>
<pre><code>$ ls -l makefile
-rw-rw-r-- 1 arnaud arnaud 477 avril 17 22:51 makefile</code></pre>
<p>Ce fichier m'appartient et appartient à mon groupe primaire. J'ai le droit de le lire et de le modifier, mon groupe primaire également, mais tous les autres utilisateurs ont seulement le droit de le lire. La représentation de ce mode, en octal, sera :</p>
<p><br /><span class="math">0400 + 0200 + 0040 + 0020 + 0004 = 0664</span><br /></p>
<p>Cette représentation en octal vous semble peut-être sortir de nulle part, mais sachez qu'elle est utilisée aussi souvent que la notation visuelle dans les appels systèmes et les commandes shell qui permettent de manipuler le mode des fichiers, à l'instar de <code>chmod</code><a href="#fn5" class="footnoteRef" id="fnref5"><sup>5</sup></a>.</p>
<p>Notez le module <code>stat</code> nous propose une fonction <code>filemode()</code> qui sert à représenter les permissions du fichier de façon visuelle :</p>
<pre class="sourceCode python"><code class="sourceCode python">&gt;&gt;&gt; stat.filemode(os.stat(<span class="st">&#39;makefile&#39;</span>).st_mode)
<span class="co">&#39;-rw-rw-r--&#39;</span></code></pre>
<p>Les plus observateurs d'entre vous l'auront remarqué : cette représentation visuelle est préfixée d'un dixième symbole alors que nous n'en avons pour l'instant lu que 9. Qu'est-il donc supposé représenter ?</p>
<p>Voyons voir :</p>
<pre class="sourceCode python"><code class="sourceCode python">&gt;&gt;&gt; stat.filemode(os.stat(<span class="st">&#39;.&#39;</span>).st_mode)
<span class="co">&#39;drwxrwxr-x&#39;</span></code></pre>
<p>En appelant <code>stat</code> sur le répertoire courant, ce dixième symbole se transforme en un <code>d</code>. D comme ? D comme di… dir… ? <em>Directory</em>, oui ! Ce dixième symbole nous donne le <em>type</em> de l'inode. Ainsi, on trouvera les flags suivants dans le module <code>stat</code> :</p>
<ul>
<li><code>S_IFREG</code>: l'inode désigne un <em>fichier régulier</em> (un fichier, quoi), représenté par le préfixe <code>-</code>.</li>
<li><code>S_IFDIR</code>: l'inode désigne un <em>répertoire</em>, représenté par le préfixe <code>d</code>.</li>
</ul>
<p>Il existe encore (plein) d'autres flags et d'autres informations encodées dans ce champ <code>st_mode</code>, mais nous allons nous contenter de ceux-ci pour l'instant<a href="#fn6" class="footnoteRef" id="fnref6"><sup>6</sup></a>. Nous découvrirons toutes les autres au fur et à mesure que nous toucherons dans ce cours aux notions qu'elles font intervenir, promis !</p>
<h3 id="modifier-les-permissions-dun-fichier"><a href="#modifier-les-permissions-dun-fichier"><span class="header-section-number">2.2.3</span> Modifier les permissions d'un fichier</a></h3>
<p>J'ai mentionné un peu plus haut la commande <code>chmod</code>. Voyons comment l'utiliser (ainsi que la fonction Python équivalente, évidemment).</p>
<p>Créons un fichier vide pour faire nos tests.</p>
<pre><code>$ touch monfichier
$ stat -c &quot;%A (%a) %U:%G&quot; monfichier
-rw-rw-r-- (664) arnaud:arnaud</code></pre>
<p>L'option &quot;<code>-c &quot;%A (%a) %U:%G&quot;</code>&quot; de la commande <code>stat</code> sert à lui dire que je veux afficher uniquement les droits (en version lisible puis en octal), le propriétaire et le groupe du fichier.</p>
<p>La façon la plus frontale de modifier les droits d'un fichier sera de passer à <code>chmod</code> la valeur octale du masque de droits. Par exemple, si je souhaite retirer les droits en écriture au groupe, je vais calculer le nouveau masque en prenant l'actuel (0664) auquel je retranche la valeur de <code>S_IRGRP</code> (0020), ce qui me donne 0644 :</p>
<pre><code>$ chmod 644 monfichier
$ stat -c &quot;%A (%a) %U:%G&quot; monfichier
-rw-r--r-- (644) arnaud:arnaud</code></pre>
<p>L'autre syntaxe acceptée par <code>chmod</code> consiste à spécifier :</p>
<ul>
<li>le(s) type(s) d'utilisateur(s) (<code>u</code> pour le propriétaire, <code>g</code> pour le groupe et <code>o</code> pour les autres),</li>
<li>l'ajout (<code>+</code>) ou le retrait (<code>-</code>) du droit,</li>
<li>la valeur du droit (<code>r</code> pour la lecture, <code>w</code> pour l'écriture, <code>x</code> pour l'exécution)</li>
</ul>
<p>Par exemple, pour rajouter les droits en exécution au propriétaire et ceux en écriture au groupe et aux autres :</p>
<pre><code>$ chmod u+x,go+w monfichier
$ stat -c &quot;%A (%a) %U:%G&quot; monfichier
-rwxrw-rw- (766) arnaud:arnaud</code></pre>
<p>Oh et puis non, en fait, je ne veux pas exécuter ce fichier ni que les autres le lisent ni écrivent dedans, finalement :</p>
<pre><code>$ chmod u-x,o-rw monfichier
$ stat -c &quot;%A (%a) %U:%G&quot; monfichier
-rw-rw---- (660) arnaud:arnaud</code></pre>
<p>En Python, cependant, cette syntaxe <em>user-friendly</em> n'existe pas. La fonction <code>os.chmod()</code> n'accepte que la valeur du masque, que vous pouvez spécifier soit de façon verbeuse en assemblant celui-ci via les flags du module <code>stat</code>.</p>
<pre class="sourceCode python"><code class="sourceCode python">&gt;&gt;&gt; os.chmod(<span class="st">&quot;monfichier&quot;</span>,
...       stat.S_IRUSR | stat.S_IWUSR | stat.S_IRGRP
... )
&gt;&gt;&gt; stat.filemode(os.stat(<span class="st">&quot;monfichier&quot;</span>).st_mode)
<span class="co">&#39;-rw-r-----&#39;</span></code></pre>
<p>Soit, ce que personnellement je trouve beaucoup plus simple, en utilisant directement la valeur octale :</p>
<pre class="sourceCode python"><code class="sourceCode python">&gt;&gt;&gt; os.chmod(<span class="st">&quot;monfichier&quot;</span>, <span class="bn">0o664</span>)
&gt;&gt;&gt; stat.filemode(os.stat(<span class="st">&quot;monfichier&quot;</span>).st_mode)
<span class="co">&#39;-rw-rw-r--&#39;</span></code></pre>
<h2 id="lecture-et-écriture-de-fichiers-au-niveau-système"><a href="#lecture-et-écriture-de-fichiers-au-niveau-système"><span class="header-section-number">2.3</span> Lecture et écriture de fichiers au niveau système</a></h2>
<p>Maintenant que nous avons une abstraction pour représenter les fichiers sur un périphérique de stockage, voyons un peu comment le noyau va présenter ces fichiers aux programmes qui sont en train de s'exécuter.</p>
<h3 id="inodes-et-descripteurs-de-fichiers"><a href="#inodes-et-descripteurs-de-fichiers"><span class="header-section-number">2.3.1</span> Inodes et descripteurs de fichiers</a></h3>
<p>Bien sûr, manipuler des fichiers est une chose très courante en programmation. Après tout, une fois que l'on a compris le fonctionnement des fonctions de base <code>open()</code>, <code>read()</code>, <code>write()</code> et <code>close()</code>, on peut se dire qu'on a fait le tour de la question… La figure 2.3 montre qu'en réalité, ces quelques appels système ne sont que la partie émergée de l'iceberg, et qu'il y a bien plus à en dire que d'expliquer leur signature !</p>
<figure>
<img src="src/img/fd_table.png" alt="Accès aux fichiers en mémoire" /><figcaption>Accès aux fichiers en mémoire</figcaption>
</figure>
<p>Alors, que se passe-t'il <em>réellement</em> lorsque vous ouvrez un fichier dans un programme ?</p>
<p>Pour commencer, le noyau va aller chercher l'inode correspondant dans le système de fichiers. Une fois qu'il a trouvé cet inode (disque), il va le charger en mémoire. Ensuite, il va rajouter une entrée dans sa <em>table des fichiers ouverts</em>, qui contient en particulier un pointeur sur cet inode (mémoire). Cette entrée va également contenir d'autres données intéressantes, comme le <em>mode d'ouverture</em> du fichier (lecture, écriture, ajout...) et un indicateur de position (pour savoir où le processus<a href="#fn7" class="footnoteRef" id="fnref7"><sup>7</sup></a> en est dans la lecture du fichier).</p>
<p>Cette table des fichiers ouverts est globale à tous les processus qui tournent sur le système. Cela permet, dans certains cas particuliers, que plusieurs processus manipulent la même entrée de la table des fichiers ouverts, mais nous verrons ce genre de choses beaucoup plus loin dans ce cours.</p>
<p>Le processus qui va chercher à manipuler ce fichier, quant à lui, dispose (côté noyau) d'une <em>table des descripteurs de fichiers</em>, qui associe, grosso-modo, un indice entier (le <strong>descripteur de fichier</strong>, qu'on abrègera FD dans la suite, pour <em>file descriptor</em>) à une entrée de la table des fichiers ouverts. Ce qu'il est intéressant de noter, c'est que cette table est <em>locale</em> au processus, tout comme les descripteurs de fichiers (puisque ce sont tout simplement les indices de cette table). Ainsi, comme le schéma nous le montre, on peut très bien avoir un programme ayant ouvert un fichier et que le noyau aura placé dans l'entrée numéro 5 de sa table des FD, et un second programme qui aura ouvert le même fichier mais en l'associant localement au FD 12.</p>
<p>Le fait que la table des descripteurs des fichiers du processus se trouve <em>côté noyau</em> n'est pas anodin, puisque ça signifie qu'on ne peut pas la manipuler directement (et donc que l'on ne peut pas faire n'importe quoi avec). Par contre, les descripteurs de fichiers sont exposés côté utilisateur, puisque ce sont eux que le programme passe en argument aux appels système <code>read</code>, <code>write</code> et <code>close</code> (et tout une palanquée d'autres dont nous nous garderons bien d'établir une liste aussi fastidieuse que superflue).</p>
<p>Ainsi, de notre point de vue d'utilisateurs des facilités du noyau, ce sont surtout ces descripteurs de fichiers qui nous intéressent.</p>
<h3 id="interactions-de-base"><a href="#interactions-de-base"><span class="header-section-number">2.3.2</span> Interactions de base</a></h3>
<p>Nous allons travailler sur un exemple simple. Nous allons copier le fichier <code>menu</code> dont le contenu est le suivant :</p>
<pre><code>$ cat menu
* spam
* eggs
* bacon
* spam
* sausage
* spam
* ham</code></pre>
<p>Pour cela, nous allons l'ouvrir, en lire le contenu, puis ouvrir un second fichier (qui n'existe pas encore) pour écrire le contenu à l'intérieur.</p>
<p>Ouvrir un fichier à bas niveau se fait grâce à l'appel système <code>os.open()</code>. Cet appel système prend au minimum en argument :</p>
<ul>
<li>le chemin vers le fichier,</li>
<li>un <em>flag</em> parmi :
<ul>
<li><code>os.O_RDONLY</code> pour ouvrir le fichier en lecture seule,</li>
<li><code>os.O_WRONLY</code> pour ouvrir le fichier en écriture seule,</li>
<li><code>os.O_RDWR</code> pour ouvrir le fichier à la fois en lecture et en écriture.</li>
</ul></li>
</ul>
<p>Sa valeur de retour est, bien sûr, le descripteur de fichier qui aura été créé dans la table locale du processus.</p>
<pre class="sourceCode python"><code class="sourceCode python">&gt;&gt;&gt; fd = os.<span class="dt">open</span>(<span class="st">&quot;menu&quot;</span>, os.O_RDONLY)
&gt;&gt;&gt; fd
<span class="dv">3</span></code></pre>
<p>Comme vous le constatez, le fichier est associé au descripteur <code>3</code> dans la table des descripteurs de fichiers. Les fd <code>0</code>, <code>1</code> et <code>2</code> étant déjà occupés par les trois flux d'entrée/sortie standard du processus, que nous découvrirons plus loin.</p>
<p>Pour lire des données dans un fichier, on appellera la fonction <code>os.read()</code> qui réalisera l'appel système du même nom, en lui passant en arguments :</p>
<ul>
<li>le descripteur de fichier à lire,</li>
<li>le nombre d'octets que nous comptons lire. Ce nombre peut être supérieur à la quantité de données restantes à lire dans le fichier, auquel cas la valeur retournée sera la totalité des données du fichier, ou bien inférieur, auquel cas un appel ultérieur nous permettra de continuer à lire les données.</li>
</ul>
<pre class="sourceCode python"><code class="sourceCode python">&gt;&gt;&gt; data = os.read(fd, <span class="dv">4096</span>)
&gt;&gt;&gt; data
b<span class="st">&#39;* spam</span><span class="ch">\n</span><span class="st">* eggs</span><span class="ch">\n</span><span class="st">* bacon</span><span class="ch">\n</span><span class="st">* spam</span><span class="ch">\n</span><span class="st">* sausage</span><span class="ch">\n</span><span class="st">* spam</span><span class="ch">\n</span><span class="st">* ham</span><span class="ch">\n</span><span class="st">&#39;</span></code></pre>
<p>Remarquez que la fonction <code>read</code> nous a retourné ici un objet de type <code>bytes</code> et non une chaîne de caractères Unicode (<code>str</code>) : il s'agit de données brutes, non décodées.</p>
<p>Ici, nous avons lu la totalité du contenu de notre fichier. Ainsi, si l'on appelle une nouvelle fois la fonction <code>read</code>, nous obtiendrons en retour une donnée vide :</p>
<pre class="sourceCode python"><code class="sourceCode python">&gt;&gt;&gt; os.read(fd, <span class="dv">4096</span>)
b<span class="st">&#39;&#39;</span></code></pre>
<p>Fermons notre fichier pour libérer le descripteur avec <code>os.close()</code> :</p>
<pre class="sourceCode python"><code class="sourceCode python">&gt;&gt;&gt; os.close(fd)</code></pre>
<p>Bien, maintenant, ouvrons le fichier <code>copie</code> en écriture :</p>
<pre class="sourceCode python"><code class="sourceCode python">&gt;&gt;&gt; fd = os.<span class="dt">open</span>(<span class="st">&quot;copie&quot;</span>, os.O_WRONLY)
Traceback (most recent call last):
  File <span class="st">&quot;&lt;stdin&gt;&quot;</span>, line <span class="dv">1</span>, in &lt;module&gt;
<span class="ot">FileNotFoundError</span>: [Errno <span class="dv">2</span>] No such <span class="dt">file</span> or directory: <span class="st">&#39;copie&#39;</span></code></pre>
<p>Python nous crache au visage que ce fichier n'existe pas. Contrairement à l'interface que vous connaissez déjà sûrement, l'appel système <code>open</code> ne va pas créer de nouveau fichier lorsque celui-ci n'existe pas. Et si celui-ci existe, il ne saura pas s'il doit l'effacer ou écrire à sa suite. C'est la raison pour laquelle les <em>flags</em> de cet appel système, lorsque l'on ouvre le fichier en écriture, doivent être combinés avec une ou plusieurs des valeurs suivantes :</p>
<ul>
<li><code>os.O_APPEND</code> : Écrire à la fin du fichier (en mode &quot;ajout&quot;) si celui-ci existe déjà,</li>
<li><code>os.O_TRUNC</code> : Tronquer le fichier (supprimer ses données) si celui-ci existe déjà,</li>
<li><code>os.O_EXCL</code> : Échouer (en Python, lever une exception) si le fichier existe déjà,</li>
<li><code>os.O_CREAT</code>: Créer le fichier si celui-ci n'existe pas encore.</li>
</ul>
<p>Lorsque l'on utilise cette dernière valeur, il est également nécessaire de fournir un argument supplémentaire à <code>os.open</code> pour spécifier le <code>mode</code> du fichier créé, avec exactement la même sémantique que la fonction <code>os.chmod</code>.</p>
<p>Ainsi, nous pouvons ouvrir ce nouveau fichier <code>copie</code> en écriture de la façon suivante :</p>
<pre class="sourceCode python"><code class="sourceCode python">&gt;&gt;&gt; fd = os.<span class="dt">open</span>(<span class="st">&quot;copie&quot;</span>, os.O_WRONLY | os.O_CREAT | os.O_TRUNC, mode=<span class="bn">0o640</span>)
&gt;&gt;&gt; fd
<span class="dv">3</span></code></pre>
<p>Remarquez que <code>fd</code> vaut ici une nouvelle fois 3 : le descripteur que nous avons fermé plus haut est réutilisé.</p>
<p>Pour écrire des données dans ce nouveau fichier, rien de plus simple :</p>
<pre class="sourceCode python"><code class="sourceCode python">&gt;&gt;&gt; os.write(fd, data)
<span class="dv">52</span></code></pre>
<p>La fonction nous retourne le nombre d'octets effectivement écrits dans le fichier, soit 52 (la taille de la donnée). Nous pouvons maintenant refermer le fichier pour éviter de charger inutilement la table des descripteurs et libérer la ressource.</p>
<pre class="sourceCode python"><code class="sourceCode python">&gt;&gt;&gt; os.close(fd)</code></pre>
<p>Nous pouvons remarquer que le fichier <code>copie</code> a bien été créé, que j'en suis évidemment propriétaire puisque c'est moi qui l'ai créé, et qu'il s'agit bien d'une copie du <code>menu</code> :</p>
<pre><code>$ ls -l copie
-rw-r----- 1 arnaud arnaud 52 avril 26 21:57 copie
$ cat copie
* spam
* eggs
* bacon
* spam
* sausage
* spam
* ham</code></pre>
<p>Rien de bien compliqué, en somme !</p>
<p>Mais que sont donc ces trois descripteurs de fichier 0, 1 et 2 ? Conventionnellement, le système va attribuer à chaque processus trois <em>flux</em> standard :</p>
<ul>
<li><code>STDIN</code> (0) : L'entrée standard du processus, qui permet par exemple de lire des données que l'utilisateur saisit au clavier,</li>
<li><code>STDOUT</code> (1) : La sortie standard, que l'on utilise conventionnellement pour afficher des données dans la console,</li>
<li><code>STDERR</code> (2) : La sortie d'erreur standard, sur laquelle on écrit les descriptions des erreurs lorsqu'elles se produisent.</li>
</ul>
<p>Ainsi, les FD 1 et 2 se comporteront comme des fichiers ouverts en écriture :</p>
<pre class="sourceCode python"><code class="sourceCode python">&gt;&gt;&gt; os.write(<span class="dv">1</span>, b<span class="st">&#39;Hello, World!</span><span class="ch">\n</span><span class="st">&#39;</span>)
Hello, World!
<span class="dv">14</span>
&gt;&gt;&gt; os.write(<span class="dv">2</span>, b<span class="st">&quot;Une erreur s&#39;est produite</span><span class="ch">\n</span><span class="st">&quot;</span>)
Une erreur s<span class="st">&#39;est produite</span>
<span class="st">26</span></code></pre>
<p>Quant à l'entrée standard, celle-ci peut être lue avec <code>read()</code>: faites l'essai en tapant du texte puis en validant avec la touche <code>&lt;Entrée&gt;</code>.</p>
<pre class="sourceCode python"><code class="sourceCode python">&gt;&gt;&gt; os.read(<span class="dv">0</span>, <span class="dv">4096</span>)
Ceci est une saisie au clavier.
b<span class="st">&#39;Ceci est une saisie au clavier.</span><span class="ch">\n</span><span class="st">&#39;</span></code></pre>
<p>Comme vous le constatez, les &quot;fichiers&quot; que le noyau nous expose peuvent également être des abstractions pour le terminal, le clavier, ou un périphérique matériel ou d'autres choses encore… Je suppose que vous comprenez, maintenant, le potentiel des quatres appels que nous venons de voir !</p>
<h2 id="linterface-haut-niveau-de-python-parce-quil-qui-vous-veut-du-bien"><a href="#linterface-haut-niveau-de-python-parce-quil-qui-vous-veut-du-bien"><span class="header-section-number">2.4</span> L'interface haut niveau de Python (parce qu'il qui vous veut du bien)</a></h2>
<p>Dans « la vraie vie », on n'a pratiquement jamais besoin d'utiliser les appels système que nous venons d'évoquer en Python. Et pour cause ! Celui-ci expose au développeur une interface beaucoup plus confortable pour manipuler des fichiers. Cette interface consiste à envelopper un <em>file descriptor</em> dans ce que Python nomme des <em>file objects</em>, et est implémentée dans le module standard <a href="https://docs.python.org/3.4/library/io.html"><code>io</code></a>.</p>
<p>L'apport majeur de cette interface à haut niveau est qu'elle présuppose plusieurs types d'interactions différents avec les fichiers :</p>
<ul>
<li>l'interaction en mode <strong>binaire</strong> assez bas niveau, qui permet de lire et écrire des données brutes dans un fichier,</li>
<li>l'interaction en mode <strong>texte</strong>, plus haut niveau, qui présuppose que les données du fichier sont du texte.</li>
</ul>
<p>Cela permet au développeur de profiter d'un grand nombre de facilités sans même avoir besoin de soupçonner l'existence de tous les mécanismes que son langage lui apporte.</p>
<h3 id="la-toute-puissante-builtin-open"><a href="#la-toute-puissante-builtin-open"><span class="header-section-number">2.4.1</span> La toute-puissante builtin <code>open()</code></a></h3>
<pre><code>TODO</code></pre>
<h3 id="les-flux-de-données-binaires"><a href="#les-flux-de-données-binaires"><span class="header-section-number">2.4.2</span> Les flux de données binaires</a></h3>
<pre><code>TODO</code></pre>
<h3 id="les-fichiers-texte"><a href="#les-fichiers-texte"><span class="header-section-number">2.4.3</span> Les fichiers texte</a></h3>
<pre><code>TODO</code></pre>
<h3 id="formatage-des-données-textuelles"><a href="#formatage-des-données-textuelles"><span class="header-section-number">2.4.4</span> Formatage des données textuelles</a></h3>
<p>Le mode texte besoin d'au moins deux paramètres pour fonctionner : l'encodage du fichier, et le délimiteur de fin de ligne, que l'on peut spécifier en argument de la builtin <code>open()</code>. Par défaut, Python utilisera ceux qui sont configurés sur le système. On peut retrouver l'encodage par défaut en nous servant du module <code>locale</code>, et le délimiteur de fin de ligne via <code>os.linesep</code> :</p>
<pre class="sourceCode python"><code class="sourceCode python">&gt;&gt;&gt; locale.getlocale()
(<span class="st">&#39;en_US&#39;</span>, <span class="st">&#39;UTF-8&#39;</span>)
&gt;&gt;&gt; os.linesep
<span class="co">&#39;\n&#39;</span></code></pre>
<p>Ces quelques lignes m'apprennent que mon système est configuré en anglais, et qu'il utilise l'encodage <code>utf-8</code> par défaut, en délimitant les lignes du symbole ASCII <code>LINE_FEED</code>.</p>
<p>Ces considérations sur l'encodage sont importantes car ni Python, ni votre système d'exploitation ne sont magiques : ils ne chercheront pas à deviner l'encodage des fichiers texte<a href="#fn8" class="footnoteRef" id="fnref8"><sup>8</sup></a>. Par exemple, si je cherche à ouvrir un fichier texte rédigé sous Windows, je risque fort de me heurter à un problème :</p>
<pre class="sourceCode python"><code class="sourceCode python">&gt;&gt;&gt; fobj = <span class="dt">open</span>(<span class="st">&#39;exemple.txt&#39;</span>, <span class="st">&#39;r&#39;</span>)
&gt;&gt;&gt; <span class="dt">print</span>(fobj.read())
Traceback (most recent call last):
  File <span class="st">&quot;&lt;stdin&gt;&quot;</span>, line <span class="dv">1</span>, in &lt;module&gt;
  File <span class="st">&quot;/usr/lib/python3.4/codecs.py&quot;</span>, line <span class="dv">313</span>, in decode
    (result, consumed) = <span class="ot">self</span>._buffer_decode(data, <span class="ot">self</span>.errors, final)
<span class="ot">UnicodeDecodeError</span>: <span class="st">&#39;utf-8&#39;</span> codec can<span class="st">&#39;t decode byte 0xe9 in position 18: ...</span></code></pre>
<p>En effet, il y a de grandes chances que ce fichier ait été encodé en <code>latin-1</code>, comme la commande <code>file</code> nous le confirme :</p>
<pre><code>$ file exemple.txt
exemple.txt: ISO-8859 text, with CRLF line terminators</code></pre>
<p>Il faudra donc spécifier cet encodage à la fonction <code>open()</code><a href="#fn9" class="footnoteRef" id="fnref9"><sup>9</sup></a>:</p>
<pre class="sourceCode python"><code class="sourceCode python">&gt;&gt;&gt; fobj = <span class="dt">open</span>(<span class="st">&#39;exemple.txt&#39;</span>, <span class="st">&#39;r&#39;</span>, encoding=<span class="st">&#39;iso-8859-1&#39;</span>)
&gt;&gt;&gt; fobj.read()
<span class="co">&#39;Donnée encodée\nen latin-1&#39;</span></code></pre>
<p>Pour comparaison, relisons ce fichier, mais cette fois-ci en mode binaire :</p>
<pre class="sourceCode python"><code class="sourceCode python">&gt;&gt;&gt; fobj = <span class="dt">open</span>(<span class="st">&#39;exemple.txt&#39;</span>, <span class="st">&#39;rb&#39;</span>)
&gt;&gt;&gt; fobj.read()
b<span class="st">&#39;Donn</span><span class="ch">\xe9e</span><span class="st"> encod</span><span class="ch">\xe9e\r\n</span><span class="st">en latin-1&#39;</span></code></pre>
<p>Au-delà des accents (qui sont encodés de façon propre au <code>latin-1</code>), nous pouvons également remarquer que le passage à la ligne est effectué via la séquence CRLF (<code>CARRIAGE_RETURN LINE_FEED</code>): <code>'\r\n'</code>, alors que dans la version décodée, celui-ci est remplacé par <code>'\n'</code>.</p>
<p>Il s'agit du comportement par défaut de Python en mode texte : les retours à la ligne sont standardisés pour correspondre à un caractère <code>'\n'</code> dans les chaînes de caractères, puis remplacés par la séquence désignée par <code>os.linesep</code> lorsqu'ils sont écrits dans un fichier.</p>
<h1 id="les-processus"><a href="#les-processus"><span class="header-section-number">3</span> Les processus</a></h1>
<h1 id="le-parallélisme-multi-processus"><a href="#le-parallélisme-multi-processus"><span class="header-section-number">4</span> Le Parallélisme multi-processus</a></h1>
<h1 id="les-threads"><a href="#les-threads"><span class="header-section-number">5</span> Les threads</a></h1>
<section class="footnotes">
<hr />
<ol>
<li id="fn1"><p>Ah oui, j'avais oublié de le préciser, mais nous sommes au début des années 1970. Vous n'imaginiez pas que quelqu'un développerait son propre pilote de disque dur de nos jours, tout de même !<a href="#fnref1">↩</a></p></li>
<li id="fn2"><p>En toute rigueur, GNU/Linux est une réécriture complète d'UNIX, mais ça ne l'empêche pas de fonctionner de la même façon et de suivre en très grande partie les mêmes standards. C'est la raison pour laquelle on le place très volontiers dans la famille des systèmes Unix.<a href="#fnref2">↩</a></p></li>
<li id="fn3"><p>Je parie que c'est la première fois que l'on vous présente le module <code>os</code> pour ce qu'il est vraiment : une collection d'appels systèmes.<a href="#fnref3">↩</a></p></li>
<li id="fn4"><p>Il y a une explication très simple à cela. Les opérateurs bit-à-bit sont extrêmement rapides en C car les microprocesseurs savent les exécuter en une seule opération, mais pas en Python où les opérations sur les entiers, quelles qu'elles soient, sont comparativement très lentes.<a href="#fnref4">↩</a></p></li>
<li id="fn5"><p>RTFM ! Non, je plaisante, on va en parler juste après. ;)<a href="#fnref5">↩</a></p></li>
<li id="fn6"><p>Par contre, si vous êtes curieux et voulez absolument en avoir un aperçu dès maintenant, alors cette fois je vous le dis très sérieusement : RTFM ! <code>man 2 stat</code> vous donnera la page du &quot;<em>fucking manual</em>&quot; à propos de l'appel système <code>stat</code>. Alternativement, <a href="https://docs.python.org/3.4/library/stat.html">la documentation du module Python <code>stat</code></a> vous dira... la même chose, en fait, mais sans vous préciser quels bits sont concernés.<a href="#fnref6">↩</a></p></li>
<li id="fn7"><p>Nous n'avons pas encore vu la notion de <em>processus</em> dans ce cours. Si cela vous perturbe, considérez qu'un processus est une instance d'un programme qui est en train de tourner sur l'ordinateur.<a href="#fnref7">↩</a></p></li>
<li id="fn8"><p>Mais certains modules non-standard de Python comme <a href="https://pypi.python.org/pypi/chardet/2.3.0">chardet</a> en sont capables.<a href="#fnref8">↩</a></p></li>
<li id="fn9"><p>Pour déterminer l'argument attendu par Python, vous pouvez vous référer à <a href="https://docs.python.org/3.4/library/codecs.html#standard-encodings">ce tableau</a> qui décrit les encodages qu'il supporte.<a href="#fnref9">↩</a></p></li>
</ol>
</section>
</body>
</html>
